import React, { useState, useMemo, useEffect, useCallback } from 'react';
import { AppChartConfig, SPSearchTermReportData, SPFilterOptions, ProductDetails } from '../types';
import { styles } from '../styles';
import { formatNumber, formatPercent, formatPrice, getNested } from '../utils';
import { useResizableColumns, ResizableTh } from '../components/ResizableTable';
import { CustomizeColumnsModal } from '../components/CustomizeColumnsModal';
import { MoreOptionsIcon, SortIcon } from '../components/Icons';

const COLUMN_CONFIG_SP_SEARCH = [
    { group: 'General', columns: [
        { id: 'asin', label: 'ASIN', format: 'text', alwaysVisible: true },
        { id: 'campaignName', label: 'Campaign Name', format: 'text' },
        { id: 'customerSearchTerm', label: 'Customer Search Term', format: 'text' },
        { id: 'targeting', label: 'Targeting', format: 'text' },
        { id: 'matchType', label: 'Match Type', format: 'text' },
    ]},
    { group: 'Performance', columns: [
        { id: 'impressions', label: 'Impressions', format: 'number' },
        { id: 'clicks', label: 'Clicks', format: 'number' },
        { id: 'costPerClick', label: 'Cost Per Click (CPC)', format: 'price' },
        { id: 'spend', label: 'Spend', format: 'price' },
    ]},
    { group: 'Sales & Conversion (7-Day)', columns: [
        { id: 'sevenDayTotalSales', label: '7 Day Total Sales', format: 'price' },
        { id: 'sevenDayAcos', label: 'Total Advertising Cost of Sales (ACOS)', format: 'percent' },
        { id: 'sevenDayRoas', label: 'Total Return on Advertising Spend (ROAS)', format: 'number' },
        { id: 'sevenDayTotalOrders', label: '7 Day Total Orders', format: 'number' },
        { id: 'sevenDayTotalUnits', label: '7 Day Total Units', format: 'number' },
    ]},
];

const DEFAULT_VISIBLE_COLUMNS_SP_SEARCH = new Set([
    'asin',
    'campaignName',
    'customerSearchTerm',
    'impressions',
    'clicks',
    'costPerClick',
    'spend',
    'sevenDayTotalSales',
    'sevenDayAcos',
]);

const TOTAL_COLUMNS_SP_SEARCH = COLUMN_CONFIG_SP_SEARCH.flatMap(g => g.columns).length;

export function SPSearchTermsView({ setChartConfig }: { setChartConfig: (config: AppChartConfig | null) => void }) {
    const [filterOptions, setFilterOptions] = useState<SPFilterOptions>({ asins: [], dates: [] });
    const [selectedAsin, setSelectedAsin] = useState<string>('');
    const [productDetails, setProductDetails] = useState<ProductDetails | null>(null);
    const [loadingProductDetails, setLoadingProductDetails] = useState(false);
    const [startDate, setStartDate] = useState<string>(() => {
        const d = new Date();
        d.setDate(d.getDate() - 8); // Default to a week ago
        return d.toISOString().split('T')[0];
    });
    const [endDate, setEndDate] = useState<string>(() => {
        const d = new Date();
        d.setDate(d.getDate() - 2); // Default to 2 days ago
        return d.toISOString().split('T')[0];
    });
    const [data, setData] = useState<SPSearchTermReportData[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [hasAppliedFilters, setHasAppliedFilters] = useState(false);
    const [isCustomizeModalOpen, setIsCustomizeModalOpen] = useState(false);
    const [visibleColumns, setVisibleColumns] = useState<Set<string>>(DEFAULT_VISIBLE_COLUMNS_SP_SEARCH);
    const [sortConfig, setSortConfig] = useState<{ key: string | null; direction: 'ascending' | 'descending' }>({ key: 'impressions', direction: 'descending' });

    const visibleColumnList = useMemo(() => {
        return COLUMN_CONFIG_SP_SEARCH.flatMap(g => g.columns).filter(c => visibleColumns.has(c.id));
    }, [visibleColumns]);

    const initialWidths = useMemo(() => {
        return visibleColumnList.map(col => {
            if (col.id === 'campaignName') return 250;
            if (col.id === 'customerSearchTerm') return 200;
            return 150;
        });
    }, [visibleColumnList]);

    const { widths: columnWidths, getHeaderProps } = useResizableColumns(initialWidths);

    useEffect(() => {
        const fetchFilters = async () => {
            try {
                setError(null);
                setLoading(true);
                const response = await fetch('http://localhost:3001/api/sp-search-terms-filters');
                if (!response.ok) {
                     const errorData = await response.json().catch(() => ({ error: 'Failed to fetch filter options. Is the backend server running?' }));
                     throw new Error(errorData.error);
                }
                const data: SPFilterOptions = await response.json();
                setFilterOptions(data);
            } catch (e) {
                const connectErrorMsg = "Failed to connect to backend. Please ensure the server and database are running and `backend/.env` is configured correctly. Check the terminal for errors.";
                if (e instanceof TypeError) {
                    setError(connectErrorMsg);
                } else if (e instanceof Error) {
                    setError(e.message);
                } else {
                    setError('An unknown error occurred.');
                }
            } finally {
                setLoading(false);
            }
        };
        fetchFilters();
    }, []);

    useEffect(() => {
        const fetchDetails = async () => {
            if (!selectedAsin) {
                setProductDetails(null);
                return;
            }
            setLoadingProductDetails(true);
            try {
                const response = await fetch(`http://localhost:3001/api/product-details?asins=${selectedAsin}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch product details');
                }
                const data: ProductDetails[] = await response.json();
                if (data.length > 0) {
                    setProductDetails(data[0]);
                } else {
                     setProductDetails({ asin: selectedAsin, error: 'Details not found.' });
                }
            } catch (error) {
                console.error("Error fetching product details:", error);
                setProductDetails({ asin: selectedAsin, error: 'Could not load details.' });
            } finally {
                setLoadingProductDetails(false);
            }
        };

        fetchDetails();
    }, [selectedAsin]);

    const handleApply = useCallback(async () => {
        if (!startDate || !endDate) return;
        if (new Date(startDate) > new Date(endDate)) {
            setError("Start date cannot be after end date.");
            return;
        }
        try {
            setHasAppliedFilters(true);
            setLoading(true);
            setError(null);
            let url = `http://localhost:3001/api/sp-search-terms?startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}`;
            if (selectedAsin) {
                url += `&asin=${encodeURIComponent(selectedAsin)}`;
            }
            const response = await fetch(url);
            if (!response.ok) {
                 const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
            const data: SPSearchTermReportData[] = await response.json();
            setData(data);
        } catch (e) {
            const connectErrorMsg = "Failed to connect to backend. Please ensure the server and database are running and `backend/.env` is configured correctly. Check the terminal for errors.";
            if (e instanceof TypeError) {
                setError(connectErrorMsg);
            } else if (e instanceof Error) {
                setError(`Failed to fetch data: ${e.message}`);
            } else {
                setError('An unknown error occurred.');
            }
            setData([]); // Clear data on error
        } finally {
            setLoading(false);
        }
    }, [selectedAsin, startDate, endDate]);

    const requestSort = (key: string) => {
        let direction: 'ascending' | 'descending' = 'descending';
        if (sortConfig.key === key && sortConfig.direction === 'descending') {
            direction = 'ascending';
        } else if (sortConfig.key === key && sortConfig.direction === 'ascending') {
            direction = 'descending';
        }
        setSortConfig({ key, direction });
    };

    const sortedData = useMemo(() => {
        let sortableItems = [...data];
        if (sortConfig.key !== null) {
            sortableItems.sort((a, b) => {
                const aValue = getNested(a, sortConfig.key!);
                const bValue = getNested(b, sortConfig.key!);

                if (aValue === null || aValue === undefined) return 1;
                if (bValue === null || bValue === undefined) return -1;
                
                if (aValue < bValue) return sortConfig.direction === 'ascending' ? -1 : 1;
                if (aValue > bValue) return sortConfig.direction === 'ascending' ? 1 : -1;
                return 0;
            });
        }
        return sortableItems;
    }, [data, sortConfig]);

    const formatCell = (item: SPSearchTermReportData, columnId: string, format: string) => {
        const value = getNested(item, columnId);
        if (value === null || value === undefined) return '-';
        switch(format) {
            case 'number': return formatNumber(value);
            case 'percent': return formatPercent(value);
            case 'price': return formatPrice(value);
            default: return value;
        }
    };

    const renderContent = () => {
        if (loading && !hasAppliedFilters && !error) return <div style={styles.message}>Loading filters...</div>;
        if (loading) return <div style={styles.message}>Loading data...</div>;
        if (error) return null;

        if (!hasAppliedFilters) {
            return <div style={styles.message}>Please select a date and click "Apply" to view data.</div>;
        }
        
        if (sortedData.length === 0) return <div style={styles.message}>No data available for the selected ASIN and date range.</div>;

        const visibleColumnConfig = COLUMN_CONFIG_SP_SEARCH.map(group => ({
            ...group,
            columns: group.columns.filter(col => visibleColumns.has(col.id))
        })).filter(group => group.columns.length > 0);

        return (
             <table style={styles.table}>
                <colgroup>
                    {columnWidths.map((width, i) => (
                        <col key={i} style={{ width: `${width}px` }} />
                    ))}
                </colgroup>
                <thead>
                    <tr>
                        {visibleColumnConfig.map(group => (
                            <th key={group.group} style={{...styles.th, ...styles.thCenter, ...styles.thGroup, ...(group.columns[0].alwaysVisible ? styles.stickyHeader : {})}} colSpan={group.columns.length}>
                                {group.group}
                            </th>
                        ))}
                    </tr>
                    <tr>
                        {visibleColumnList.map((col, index) => (
                            <ResizableTh
                                key={col.id}
                                index={index}
                                getHeaderProps={getHeaderProps}
                                sticky={col.alwaysVisible}
                            >
                                <div style={{...styles.thContent, cursor: 'pointer'}} onClick={() => requestSort(col.id)}>
                                    <span>{col.label}</span>
                                    <div>
                                        {sortConfig.key === col.id ? <SortIcon direction={sortConfig.direction} /> : <SortIcon direction="none" />}
                                        <MoreOptionsIcon />
                                    </div>
                                </div>
                            </ResizableTh>
                        ))}
                    </tr>
                </thead>
                <tbody>
                    {sortedData.map((item, index) => (
                        <tr key={`${item.campaignName}-${item.customerSearchTerm}-${index}`} style={styles.tr}>
                           {visibleColumnList.map(col => (
                                <td key={col.id} 
                                    style={{
                                        ...styles.td, 
                                        ...(col.alwaysVisible ? styles.stickyColumn : {}),
                                    }}
                                >
                                    {col.id === 'asin' && item.asin ? (
                                        <a href={`https://www.amazon.com/dp/${item.asin}`} target="_blank" rel="noopener noreferrer" style={styles.link}>
                                            {item.asin}
                                        </a>
                                    ) : (
                                        formatCell(item, col.id, col.format)
                                    )}
                                </td>
                           ))}
                        </tr>
                    ))}
                </tbody>
            </table>
        )
    };

    const filtersDisabled = loading || !!error;

    return (
        <div style={styles.viewContainer}>
            {isCustomizeModalOpen && (
                <CustomizeColumnsModal 
                    visibleColumns={visibleColumns}
                    onClose={() => setIsCustomizeModalOpen(false)}
                    onSave={setVisibleColumns}
                    columnConfig={COLUMN_CONFIG_SP_SEARCH}
                />
            )}
            <header style={styles.header}>
                <div>
                    <h1 style={styles.title}>Sponsored Products Search Term Report</h1>
                    <p style={styles.subtitle}>Analyze the performance of search terms that triggered your Sponsored Products ads, showing which terms lead to clicks and sales.</p>
                </div>
            </header>
            <div style={styles.card}>
                <div style={styles.filterGroup}>
                    <label style={styles.label} htmlFor="asin-select-sp">ASIN</label>
                    <select id="asin-select-sp" style={styles.select} value={selectedAsin} onChange={e => setSelectedAsin(e.target.value)} disabled={filtersDisabled || filterOptions.asins.length === 0}>
                        <option value="">All ASINs</option>
                        {filterOptions.asins.map(asin => <option key={asin} value={asin}>{asin}</option>)}
                    </select>
                </div>
                 <div style={styles.filterGroup}>
                    <label style={styles.label} htmlFor="start-date-sp">Start Date</label>
                    <input
                        type="date"
                        id="start-date-sp"
                        style={styles.input}
                        value={startDate}
                        onChange={e => setStartDate(e.target.value)}
                        disabled={filtersDisabled}
                    />
                </div>
                <div style={styles.filterGroup}>
                    <label style={styles.label} htmlFor="end-date-sp">End Date</label>
                    <input
                        type="date"
                        id="end-date-sp"
                        style={styles.input}
                        value={endDate}
                        onChange={e => setEndDate(e.target.value)}
                        disabled={filtersDisabled}
                    />
                </div>
                <button onClick={handleApply} style={styles.primaryButton} disabled={filtersDisabled || !startDate || !endDate}>
                    {loading ? 'Loading...' : 'Apply'}
                </button>
                 <div style={styles.productInfoContainer}>
                    {loadingProductDetails ? (
                        <p style={{ margin: 0, color: 'var(--text-muted-color)' }}>Loading details...</p>
                    ) : productDetails ? (
                        <>
                            <img 
                                src={productDetails.imageUrl || 'https://via.placeholder.com/50x50.png?text=N/A'} 
                                alt={productDetails.title || 'Product image'} 
                                style={styles.productInfoImage} 
                            />
                            <div style={styles.productInfoText}>
                                <p style={styles.productInfoTitle} title={productDetails.title}>{productDetails.title || 'Title not available'}</p>
                                <p style={styles.productInfoAsin}>{productDetails.asin}</p>
                            </div>
                        </>
                    ) : (
                         <p style={{ margin: 0, color: 'var(--text-muted-color)' }}>Select an ASIN to see details.</p>
                    )}
                </div>
            </div>

            {error && <div style={{...styles.error, padding: '1rem', backgroundColor: 'rgba(220, 53, 69, 0.05)', border: '1px solid rgba(220, 53, 69, 0.2)', borderRadius: 'var(--border-radius)', marginTop: '1rem' }}>{error}</div>}
            
             <main style={{ marginTop: '1.5rem' }}>
                <div style={styles.tableActions}>
                    <span style={styles.tableInfo}>Displaying {sortedData.length} of {sortedData.length} search terms</span>
                    <button style={styles.linkButton} onClick={() => setIsCustomizeModalOpen(true)}>
                        Customize Columns ({TOTAL_COLUMNS_SP_SEARCH})
                    </button>
                </div>
                <div style={styles.tableContainer}>
                    {renderContent()}
                </div>
            </main>
        </div>
    );
}